#!/bin/python
import os
import sys
import time
import re
import inquirer as inq
from platform import system
from lists_header import *
from colors import bcolors as colors

# ------ Help menu
print_help = lambda: print("Usage: rns \"Videos directory\" \"Subtitles directory\"")
if sys.argv[1] in ['-h', '--help']:
    print_help()
    exit()

# -------------------- Getting static vars
elif len(sys.argv) == 3:
    os_name = system()                  # Getting operating system's name
    video_path = sys.argv[1]            # Video path from arguments 
    sub_path = sys.argv[2]              # Subtitles path from arguments
# ----- Getting right subs path
else:
    print_help()
    exit()

try:
    os.chdir(sub_path)
except FileNotFoundError:
    print(colors.RED + "Wrong Subtitles path, File not found ):" + colors.ENDC)
    print(colors.WARNING + "Please use a valid path" + colors.ENDC)
    exit()
sub_path = os.getcwd()
# ----- Getting righ video path
try:
    os.chdir(video_path)
except FileNotFoundError:
    print(colors.RED + "Wrong Videos path, File not found ):" + colors.ENDC)
    print(colors.WARNING + "Please use a valid path" + colors.ENDC)
    exit()
video_path = os.getcwd()

# ----- Processing the lists
videos = os.listdir(video_path)
videos = [video for video in videos if isvideo(video)]
videos.sort()
subs = os.listdir(sub_path)
subs = [sub for sub in subs if issub(sub)]
subs.sort()

# -------------------- Menus
confirm_menu = [
        inq.Confirm("istrue",
            message = "Yes or No.",
            default = "True"),
        ]
video_or_sub_menu = [
        inq.List("op",
            message = "Reorder the",
            choices = ['videos', 'subtitles']),
        ]

# ------------------ Define funcs
if os_name.lower() in ["linux", "unix"]:
    copy = lambda org, dst: os.system(f"cp \"{org}\" \"{dst}\"")
    clear = lambda: os.system("clear")
elif os_name.lower() in ["windows"]:
    copy = lambda org, dst: os.system(f"copy \"{org}\" \"{dst}\"")
    clear = lambda: os.system("cls")

endl = lambda: print('\n')

# Reorder a list 
def re_order(org):
    clear()
    org_menu = [
            inq.List('op',
                message = "An item to move",
                choices = [item for item in org]
                ),
            ]
    ans = inq.prompt(org_menu)
    ans = ans['op']
    ans_index = org.index(ans)
    alist = [item for item in org]
    alist.pop(ans_index)
    sec_menu = [
            inq.List('op',
                message = "An item to replace with",
                choices = [item for item in alist]
                ),
            ]
    sec_ans = inq.prompt(sec_menu)
    sec_ans = sec_ans['op']
    sec_ans_index = alist.index(sec_ans) + 1
    print(f"Replace {ans} -> {sec_ans}")
    confirm = inq.prompt(confirm_menu)
    confirm = confirm['istrue']
    if confirm:
        org[ans_index], org[sec_ans_index] = org[sec_ans_index], org[ans_index]
        clear()
        print('The new order')
        printlist(org, enum = True)
        endl()
        print("Move another one ?")
        confirm = inq.prompt(confirm_menu)
        confirm = confirm['istrue']
        if confirm:
            re_order(org)
        else:
            return True
    else:
        re_order(org)

def delete(org):
    delete_menu = [
            inq.List('op',
                message = "An item to delete",
                choices = [item for item in org]
                ),
            ]
    item_to_delete = inq.prompt(delete_menu)
    item_to_delete = item_to_delete['op']
    print("Are you sure you want to delete this item ?")
    ans = inq.prompt(confirm_menu)
    ans = ans['istrue']
    if ans:
        org.remove(item_to_delete)
        endl()
        print("Do you want to delete another item ?")
        ans = inq.prompt(confirm_menu)
        ans = ans['istrue']
        if ans :
            delete(org)
        else:
            return True
    else:
        print("Do you want to delete another item ?")
        ans = inq.prompt(confirm_menu)
        ans = ans['istrue']
        if ans :
            delete(org)
        else:
            return False

# A menu for controling reodering lists 
def re_order_menu():
    clear()
    ans = inq.prompt(video_or_sub_menu)
    ans = ans['op']
    if "video" in ans:
        delete(videos)
        print("Do you want to change the order ?")
        ans = inq.prompt(confirm_menu)
        if ans['istrue']:
            re_order(videos)
    elif "sub" in ans:
        delete(subs)
        print("Do you want to change the order ?")
        ans = inq.prompt(confirm_menu)
        if ans["istrue"]:
            re_order(subs)
    else:
        print("Unkown option ):")
        return 0
    return 1

# Print the lists to start the copy process
def print_sorted_menu():
    clear()
    print(colors.BLUE + "Videos:" + colors.ENDC)
    printlist(videos)
    endl()
    print(colors.BLUE + "Subtitles:" + colors.ENDC)
    printlist(subs)

    if len(subs) != len(videos):
        print( colors.WARNING + "Warrning: Videos and Subitiles files don't have same number." + colors.ENDC)

# Rename by a format
def rename():
    clear()
    print(colors.WARNING + "Enter the video naming format, For example:" + colors.ENDC)
    print("BreakingBad.S01E02.mp4 will become BreakingBad.S" + colors.GREEN + "@s" + colors.ENDC + "E" + colors.GREEN + "@e" + colors.ENDC + ".mp4")
    video_name = input(">>> ")
    seasons_list = []
    videos_manual = []
    seasons_number = int(input("Please enter The Seasons number: "))
    for i in range(1, seasons_number + 1):
        try:
            season_ep = int(input(f"How many Episodes in Season {i}: "))
        except ValueError:
            print("This is not a number ):")
            time.sleep(1)
            manual_menu()
        l = [season_ep]
        seasons_list.append(l)
    for index, li in enumerate(seasons_list):
        endl()
        tmp_video_name = video_name
        s = "%.2d" % (index + 1)
        print("Season: " + s)
        for e in range(1,li[0] + 1):
            e = "%.2d" % e
            video_name = video_name.replace("@s", s)
            video_name = video_name.replace("@e", e)
            video_format = get_video_format(video_name)
            sub_format = get_sub_format(subs[0])
            video_name = video_name.replace(video_format, "")
            video_name += sub_format
            print(video_name)
            videos_manual.append(video_name)
            video_name = tmp_video_name
    return videos_manual

# Main menu func
def main_menu():
    clear()
    choice = [
            inq.List('op',
                message = "Process to do",
                choices = ['Auto', 'Manual', 'Just exit'],
                ),
            ]
    choice = inq.prompt(choice)
    choice = choice['op']
    if "Auto" in choice:
        return rename_to_list(subs, videos)
    elif "Manual" in choice:
        return rename()
    elif "exit" in choice:
        print("Good bye...")
        exit()

    else:
        print("Unkown option ):")
        time.sleep(1)
        main_menu()

def rename_copy(subs, renamed_sub_list):
    print("Copping subs from", sub_path, "to", video_path)
    for org_sub, renamed_sub in zip(subs, renamed_sub_list):
        org_sub_path = os.path.join(sub_path, org_sub)
        target_sub_path = os.path.join(video_path, renamed_sub)
        copy(org_sub_path, target_sub_path)

# Main
def main():
    endl()
    print_sorted_menu()
    print("Are you ok with this sorting ?")
    ans = inq.prompt(confirm_menu)
    if ans['istrue']:
        renamed_sub_list = main_menu()
        rename_copy(subs, renamed_sub_list)
    else:
        if not re_order_menu():
            main()
        else:
            renamed_sub_list = main_menu()
            rename_copy(subs, renamed_sub_list)

if __name__=="__main__":
    try:
        main()
    except KeyboardInterrupt:
        endl()
        print(colors.RED + "Are you sure you want to exit ?" + colors.ENDC)
        ans = inq.prompt(confirm_menu)
        ans = ans['istrue']
        if ans:
            print(colors.RED + "Quitting...")
            exit()
        else:
            main()

